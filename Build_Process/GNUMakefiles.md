# Makefiles
There's a million and one excellent resources on makefiles out there, so this article is less of a tutorial and more of a collection of interesting things.

## Useful Features
- override
- immediate vs delayed macro expansion
- target chains
- built in functions (patsubst, shell, wildcard) 

## GNUMakefile vs Makefile
There's multiple different make-like programs out there, a lot of them share a common base, usually the one specified in posix. GNU make also has a bunch of custom extensions it adds, which can be quite useful. These will render your makefiles only usable for gnu make, which is the most common version. So this is fine, but if you care about being fully portable between make versions, you'll have to avoid these.

If you do use gnu make extensions, you now have a makefile that wont run under every version of make. Fortunately the folks at gnu allow you to name your makefile `GNUMakefile` instead, and this will run as normal. However other versions of make won't see this file, meaning they wont try to run it.

## GNU Make Extensions
- Coming soon!

## Simple Makefile Example
```makefile
#toolchain
CC = x86_64-elf-gcc
CXX = x86_64-elf-g++
AS = x86_64-elf-as
LD = x86_64_elf-ld

#inputs
C_SRCS = kernel_main.c util.c
ASM_SRCS = boot.S
TARGET = build/kernel.elf

#flags
CC_FLAGS = -g -ffreestanding
LD_FLAGS = -T linker_script.lds -ffreestanding

#auto populated variables
OBJS = $(patsubst %.c, build/%.c.o, $(C_SRCS)) 
OBJS += $(patsubst %.S, build/%.S.o, %(ASM_SRCS))

.PHONY: all clean

all: $(OBJS)
    @echo "Linking program ..."
    $(LD) $(LD_FLAGS) $(OBJS) -o $(TARGET)
    @echo "Program linked, placed @ $(TARGET)"

clean:
    @echo "Cleaning build files ..."
    -rm -r build/
    @echo "Cleaning done!"

build/%.c.o: %.c
    @echo "Compiling C file: $<"
    @mkdir -p $(shell dirname $@)
    $(CC) $(CC_FLAGS) $< -c -o $@

build/%.S.o: %.S
    @echo "Assembling file: $<"
    @mkdir -p $(shell dirname $@)
    $(AS) $< -c -o $@
```

Okay! So there's a lot going on there. This is just how I like to organise my makefiles, and by no means a definitive guide.
Since we may be using a cross compiler or changing compilers (it's a good idea to test with both gcc and clang) we've declared some variables representing the various programs we'll call when compiling. `CXX` is not used here, but if you're using c++ it's the common name for the compiler.

Following that we have our inputs, `C_SRCS` is a list of our source files. Anytime we want to compile a new file, we'll add it here. The same goes for `ASM_SRCS`. Why do we have two lists of sources? Because they're going to be processed by different tools (c files -> c compiler, assembly files -> assembly compiler/assembler). `TARGET` is the output location and name of the file we're going to compile.

Next up we have flags for the c compiler (`CC_FLAGS`) and the linker (`LD_FLAGS`). If we wanted flags for the assembler, we could a variable here for those too. After the flags we have our first example of where make can be really useful. 

The linker wants a list of compiled object files, from the c compiler or assembler, not a list of the source files they came from. We already maintain a list of source files as inputs, but we dont have a list of the produced object files that the linker needs to know what to link in the final binary. We could create a second list, and keep that up to date, but that's more things to keep track off. More room for error as well.
Make has built in search and replace functionality, in the form of the `patsubst` (pattern substitution) function. `patsubst` uses the wildcard (`%`) symbol to indicate the section of text we want to keep. Anything specified outside of the wildcard is used for pattern matching. It takes the following arguments:
- Pattern used to select items from the input variable.
- Pattern used to transform selected items into the output.
- Input variable.

Using `patsubst` we can transform the list of source files into a list of object files, that we can give to the linker. The second line `OBJS += ...` functions in the same way as the first, but we use the append operator instead of assign. Similar to how they work in other languages, here we *append* to the end of the variable, instead of overwriting it.

```makefile
#the c compiler we want to use
CC = x86_64-elf-gcc
#the c++ compiler we want to use. Unused in this example, but the common name for it.
CXX = x86_64-elf-g++
#the assembler we want to use
AS = x86_64-elf-as
#our linker of choice
LD = x86_64_elf-ld
#our source files (bother c and assembly)
C_SRCS = kernel_main.c util.c
ASM_SRCS = boot.S
#the output name of our final binary
TARGET = build/kernel.elf

#flags passed to the c compiler and linker
CC_FLAGS = -g -ffreestanding
LD_FLAGS = -T linker_script.lds -ffreestanding

#populated by make, contains all of our object files generated by the compiler + assembler
#we use the $(patsubst 1, 2, 3) built in func here. It takes 3 args:
# 1) what to use as input, % means wildcard.
# 2) how to transform the input into the output. In this case use the contents of the wildcard, and then append '.c.o'.
# 3) the source to use for processing, we want to use C_SRCS the first time, and then the assembly files for the second time.
OBJS = $(patsubst %.c, build/%.c.o, $(C_SRCS)) $(patsubst %.S, build/%.S.o, %(ASM_SRCS))

#a special target, always runs it's subordinate targets regardless of whether they're outdated or not.
.PHONY: all clean

#note that 'all' is the first target, this is what will run when we simply run `make` in a directory
all: $(OBJS)
    #because the object files are a dependency, they will be built before running this step, hence we are only linking here.
    #notice the '@' before the line, this means make will not output the command to the standard out. Useful since we are using echo to output a status message to the user.
    @echo "Linking program ..."
    $(LD) $(LD_FLAGS) $(OBJS) -o $(TARGET)
    #yes, we can use macros inside of strings!
    @echo "Program linked, placed @ $(TARGET)"

clean:
    @echo "Cleaning build files ..."
    #note the '-' before the command, that means that make will not abort if the command files (i.e. returns non-zero).
    -rm -r build/
    @echo "Cleaning done!"

#this is a more generic rule. Make will see that it needs 'kernel_main.c.o' and 'util.c.o' by looking at $(OBJS) above, and here we tell it how to create any files that end with '.c.o' using the wildcard.
#we specify a c file of the same name as a dependency. This is incase you add a file C_SRCS but no file exists, it will fail to compile.
#the contents of this rule will compile one file. Make will apply this rule to each item in $(OBJS).
#make will also check the time of the input and output, and only run the rule if the input is newer than the output. Otherwise it can be assumed that the file hasn't been edited, and does not need to be recompiled, saving time.
build/%.c.o: %.c
    # '$<' is a special symbol, it means the first dependency. In this case it will be the name of the c source.
    @echo "Compiling C file: $<"
    # we use the $(shell) built in to run a shell command, in this case dirname. We pass this to mkdir to ensure the output folder path exists.
    # '$@' is another special symbol, it means the target name. In this it'll be something like 'build/kernel_main.c.o' for the source file kernel_main.c.
    @mkdir -p $(shell dirname $@)
    #-c is used to only compile, not link. -o specifies output name (instead of the default a.out).
    $(CC) $(CC_FLAGS) $< -c -o $@
```

That's a lot of text! But here we can see an example of a number of make functions being used. This provides a simple, but very flexible build system for a project, even allowing the tools to be swapped out by editing a few lines.

There are other built in functions and symbols that have useful meanings, however discovering them is left as an exercise to the reader.

## Complex Makefile Example (with recursion!)
What about bigger projects? Well you aren't limited to a single makefile, one makefile can include another one (essentially copy-pasting it into the current file) using the `include` keyword. 
For example, to include `extras.mk` (.mk is a common extension for non-primary makefiles) into `Makefile` you would add the line somewhere:
```makefile
include extras.mk
```

This would place the contents of the included file *at the line where it was included*. This means the usual top to bottom reading of a makefile is followed as well. This works similar to how `#define` works in C/C++.

One import note about using `import` is to remember that the included file will run with the current directly of the file that uses import, not the directly of the where the included file is.

You can also run `make` itself as part of a command to build a target. This opens the door to a whole new world of makefiles calling further makefiles and including othes.

### Think Bigger!
*__Authors Note:__ This section is written using a personal project as a reference, there are definitely other ways to approach this, but I thought it would be an interesting exaple to look at how I approached this for my kernel/OS. - DT.*

Now what about managing a large project with many sub-projects, custom and external libraries that all interact? As an example lets look at the northport os, it features the following structure of makefiles:

```
northport/
    | - initdisk/
    |   \ - Makefile
    |
    | - kernel/
    |   | - arch/x86_64/
    |   |   \ - Local.mk
    |   | - arch/rv64/
    |   |   \ - Local.mk
    |   \ - Makefile
    |
    | - libs/
    |   | - Makefile
    |   |
    |   | - np-syslib/
    |   |   \ - Makefile
    |   |
    |   | - np-graphics/
    |   |   \ - Makefile
    [ ... other northport libs here]
    |
    | - userland/
    |   | - Makefile
    |   |
    |   | - startup/
    |   |   \ - Makefile
    |   |
    |   | - window-server/
    |   |   \ - Makefile
    [ ... other northport apps here]
    |
    | - misc/
    |   | - UserlandCommon.mk
    |   \ - LibCommon.mk
    |
    | - BuildPrep.mk
    | - Run.mk
    \ - Makefile
```

Whew, there's a lot going on there! Let's look at why the various parts exist:
- The root makefile is the one being read by make 
