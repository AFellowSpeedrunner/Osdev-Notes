# Makefiles
There's a million and one excellent resources on makefiles out there, so this article is less of a tutorial and more of a collection of interesting things.

## Useful Features
- override
- immediate vs delayed macro expansion
- target chains
- built in functions (patsubst, shell, wildcard) 

## GNUMakefile vs Makefile
There's multiple different make-like programs out there, a lot of them share a common base, usually the one specified in posix. GNU make also has a bunch of custom extensions it adds, which can be quite useful. These will render your makefiles only usable for gnu make, which is the most common version. So this is fine, but if you care about being fully portable between make versions, you'll have to avoid these.

If you do use gnu make extensions, you now have a makefile that wont run under every version of make. Fortunately the folks at gnu allow you to name your makefile `GNUMakefile` instead, and this will run as normal. However other versions of make won't see this file, meaning they wont try to run it.

## GNU Make Extensions
- Coming soon!

## Simple Makefile Example
```makefile
#the c compiler we want to use
CC = x86_64-elf-gcc
#the c++ compiler we want to use. Unused in this example, but the common name for it.
CXX = x86_64-elf-g++
#the assembler we want to use
AS = x86_64-elf-as
#our linker of choice
LD = x86_64_elf-ld
#our source files (bother c and assembly)
C_SRCS = kernel_main.c util.c
ASM_SRCS = boot.S
#the output name of our final binary
TARGET = build/kernel.elf

#flags passed to the c compiler and linker
CC_FLAGS = -g -ffreestanding
LD_FLAGS = -T linker_script.lds -ffreestanding

#populated by make, contains all of our object files generated by the compiler + assembler
#we use the $(patsubst 1, 2, 3) built in func here. It takes 3 args:
# 1) what to use as input, % means wildcard.
# 2) how to transform the input into the output. In this case use the contents of the wildcard, and then append '.c.o'.
# 3) the source to use for processing, we want to use C_SRCS the first time, and then the assembly files for the second time.
OBJS = $(patsubst %.c, build/%.c.o, $(C_SRCS)) $(patsubst %.S, build/%.S.o, %(ASM_SRCS))

#a special target, always runs it's subordinate targets regardless of whether they're outdated or not.
.PHONY: all clean

#note that 'all' is the first target, this is what will run when we simply run `make` in a directory
all: $(OBJS)
    #because the object files are a dependency, they will be built before running this step, hence we are only linking here.
    #notice the '@' before the line, this means make will not output the command to the standard out. Useful since we are using echo to output a status message to the user.
    @echo "Linking program ..."
    $(LD) $(LD_FLAGS) $(OBJS) -o $(TARGET)
    #yes, we can use macros inside of strings!
    @echo "Program linked, placed @ $(TARGET)"

clean:
    @echo "Cleaning build files ..."
    #note the '-' before the command, that means that make will not abort if the command files (i.e. returns non-zero).
    -rm -r build/
    @echo "Cleaning done!"

#this is a more generic rule. Make will see that it needs 'kernel_main.c.o' and 'util.c.o' by looking at $(OBJS) above, and here we tell it how to create any files that end with '.c.o' using the wildcard.
#we specify a c file of the same name as a dependency. This is incase you add a file C_SRCS but no file exists, it will fail to compile.
#the contents of this rule will compile one file. Make will apply this rule to each item in $(OBJS).
#make will also check the time of the input and output, and only run the rule if the input is newer than the output. Otherwise it can be assumed that the file hasn't been edited, and does not need to be recompiled, saving time.
build/%.c.o: %.c
    # '$<' is a special symbol, it means the first dependency. In this case it will be the name of the c source.
    @echo "Compiling C file: $<"
    # we use the $(shell) built in to run a shell command, in this case dirname. We pass this to mkdir to ensure the output folder path exists.
    # '$@' is another special symbol, it means the target name. In this it'll be something like 'build/kernel_main.c.o' for the source file kernel_main.c.
    @mkdir -p $(shell dirname $@)
    #-c is used to only compile, not link. -o specifies output name (instead of the default a.out).
    $(CC) $(CC_FLAGS) $< -c -o $@
```

That's a lot of text! But here we can see an example of a number of make functions being used. This provides a simple, but very flexible build system for a project, even allowing the tools to be swapped out by editing a few lines.

There are other built in functions and symbols that have useful meanings, however discovering them is left as an exercise to the reader.

## Complex Makefile Example (with recursion!)
What about bigger projects? Well you aren't limited to a single makefile, one makefile can include another one (essentially copy-pasting it into the current file) using the `include` keyword. 
For example, to include `extras.mk` (.mk is a common extension for non-primary makefiles) into `Makefile` you would add the line somewhere:
```makefile
include extras.mk
```

This would place the contents of the included file *at the line where it was included*. This means the usual top to bottom reading of a makefile is followed as well. This works similar to how `#define` works in C/C++.

One import note about using `import` is to remember that the included file will run with the current directly of the file that uses import, not the directly of the where the included file is.

You can also run `make` itself as part of a command to build a target. This opens the door to a whole new world of makefiles calling further makefiles and including othes.

### Think Bigger!
*__Authors Note:__ This section is written using a personal project as a reference, there are definitely other ways to approach this, but I thought it would be an interesting exaple to look at how I approached this for my kernel/OS. - DT.*

Now what about managing a large project with many sub-projects, custom and external libraries that all interact? As an example lets look at the northport os, it features the following structure of makefiles:

```
northport/
    | - initdisk/
    |   \ - Makefile
    |
    | - kernel/
    |   | - arch/x86_64/
    |   |   \ - Local.mk
    |   | - arch/rv64/
    |   |   \ - Local.mk
    |   \ - Makefile
    |
    | - libs/
    |   | - Makefile
    |   |
    |   | - np-syslib/
    |   |   \ - Makefile
    |   |
    |   | - np-graphics/
    |   |   \ - Makefile
    [ ... other northport libs here]
    |
    | - userland/
    |   | - Makefile
    |   |
    |   | - startup/
    |   |   \ - Makefile
    |   |
    |   | - window-server/
    |   |   \ - Makefile
    [ ... other northport apps here]
    |
    | - misc/
    |   | - UserlandCommon.mk
    |   \ - LibCommon.mk
    |
    | - BuildPrep.mk
    | - Run.mk
    \ - Makefile
```

Whew, there's a lot going on there! Let's look at why the various parts exist:
- The root makefile is the one being read by make 
