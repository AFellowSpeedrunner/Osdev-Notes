# Handling scancodes

Handling the keyboard interrupt was pretty simple, we just basically needed to add an irq to the APIC and read the scancode. But at the end what we got is just a number, and we want to eventually translated it into a character. 

In this section we will see see how to build the Keyboard driver, and what are its responsibilities. 

First of all the driver is not responsible of translating the scancode into printable characters (well sometime on early stages of development it does it too...)

What it cares is only to keep track of the various keyboard events and make them available to any service that needs them.

As already mentioned there are 3 different scancode sets, we will focus on just one (the set 1, since most of the keyboard even if using a different set will have the controller that automatically translates the scancode to that), by the way we will try to implement a generic way to translate, so when eventually a new set needs to be added the changes needed will be very little. 

Now let's see what are the problem we need to solve when developing a keyboard driver: 

* We need to store the history of key press and their status somewhere.
* There are some special keys also that needs to be handled, and some combinations that we should handle (shift or alt or ctrl  key pressed, are one example)
* Handle the press/release status if needed (we don't care much when we release a normal key, but probably we should take care when we release a key like shift or similars)
* Try to not lose sequence of key pressed/released
* Handle the caps, num, screen locks (with the leds)
* We need to translate the scancode into a human readable character when needed

From now on we will assume that the scancode translation is enabled, so no matter what set is being used it will be translate to set 1. 

## High Level Overview

In the previous section we have seen how the interrupt was generated and how to read data from the keyboard. But now we need to write a proper driver, trying to address the issues listed above (well not all of them since some are an higher level than they will be implemented "using" the driver, not by it.

We will try to build the driver in small step adding one piece at time, so it will be easier to understand it. 

### Store key press history

Of course the first thing we want to keep track of what is going on with the keyboard, we want to have a small buffer of what is being pressed released so far, and this is simple, we just need to declare an array to store the scancode read so far, the size of it is totally up to you, it doesn't need to be too big, in our example we will go for 255 items. We don't need to keep track of very old events, so when we reach the end of the buffer we will start over from the beginning (it is called a _circular buffer_)

What variable types the array should contain? Well the answer depends on several factors, for example: they set used, design decision, how we handle the special buttons. For example if we just want to store the scancode without any extra information we can just create an array of `uint8_t`:

```c
#define MAX_KEYB_BUFFER_SIZE    255

uint8_t keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;
```

If we want to store just the scancode we don't need much more so we can already implement our new irq handling function:

```c

void keyboard_driver_irq_handler() {

    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position] = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}

```

And we are done, this first function will keep track of the scancode generated by the keypress, and since we are using the set 1 it also will tell us if the button has been pressed (MAKE) or released (BREAK).

Now using uint8_t as buffer it can work in this exteremely simple scenario, but it make our driver hard to expand for future updates, for example what if we want to add some extra information with a single keypress event (and we will!)? So the first improvement we are going to make is creating a data structure that for now have just one field with the scancodae, but will make future expansion easier and more readable:

```c
typedef struct {
    uint8_t code;
} key_event;
```

So the updated irq function will be: 
```c
#define MAX_KEYB_BUFFER_SIZE    255

key_event keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;

void keyboard_driver_irq_handler() {    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position].code = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}
``` 

Even if this implementation has a lot of limitations, we implemented the first part of our driver: the circular buffer. Next we will see how to keep track of key press/released.

### Handle multi-byte scancodes

Dependending on the scancode set there are some keys that generated a scancode bigger than one byte. That means that we will have one IRQ generated for every byte placed on the data port. For example when using the scancode set 1 there are some keys (i.e. ctrl, shift, alt) that have a prefix number `0xE0`. Now the problem is that we can't read both bytes in one single irq, because even if we do, we still get two irqs generated. We need to keep track of the current reading status. To do that we will implement a very simple State Machine that have two states:

* _Normal State_, it is the standard state, also the one the driver starts in. If it read any byte that is not a prefix it will keep staying in this state, or it will re-enter into this state after a read while in the prefix state.
* _Prefix state_, in case it encountered a prefix (`0xE0`) the driver will enter into this state, in this way the next read will be completing the multi-byte scancode, and the driver will be able to identify the driver.

If you don't know what a state machine is look in the Useful Link section, for the wikipedia page. Btw the concept is pretty simple, is an algorithm that can be in one single state at each time, and update the states according to the input. In our case to implement it we need to add a global variable for the driver status, and for readability purpose two label that identifies the states.

```c
#define NORMAL_STATE 0
#define PREFIX_STATE 1

uint8_t current_state;
```

Now there are three scancodes thate are composed by  4 or 5, we are not going to cover them, but it can be a good exercise trying to find states for them too. The keys are Print Screen pressed/released and Pause (only pressed, it doesn't have a release state).

Now the first question is: do we need to store the prefix? Well for this one the answer is that it mostly depends on the design decision for the driver, but it is not necessary, especially if we are going to translate the keyboard scancodes into kernel scancodes (in this way we don't store a set specific code, and supporting multiple scancode will require less code, since the translation into a symol will be done from the kernel code and not the scancode). 

The state update is done by just updating the current_state variable. As already said that variable will start with the Normal State, so we will need an init function to e called before enabling the IRQ: 

```c
#define NORMAL_STATE 0
#define PREFIX_STATE 1

uint8_t current_state;

void init_keyboard() {
    // Do other initialization stuff like: clean the keyboard buffer, identify the scancode set, enable the IRQ etc.
    current_state = NORMAL_STATE;
}

void keyboard_driver_irq_handler() {
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    if (scancode == 0xE0) {
        current_state = PREFIX_STATE
        // We have read a prefix, so let's update the state and finish here
        // this is a very simple scenario, there could be more needed depending on the design
        return;
    }
    if (current_state == PREFIX_STATE) {
        // Do what you need to store the key_code and eventually translate it to the kernel_code and return to the normal state
        current_state = NORMAL_STATE;
    }
}
```

The code snippet above just show how the states are updated, it doesn't care about the rest. Of course the state machine we have implemente is a very simple one, but if we are going for example to add support for the Print Screen and Pause key, it will probably have more states. The buffer update code can be reused from the previous paragraph. 
### Handling Press/Release status

In the previous paragraph we implemented the circular buffer and we now store every scancode that has been generated by the keyboard, now we will see how to store the button status (pressed or released).

> **_NOTE:_** Remember: the IRQ is fired for every byte put on the keyboard data buffer (and some keys generate a mutibyte scancode).



### TODO 

- Add syscall information 
