# Handling scancodes

Handling the keyboard interrupt was pretty simple, we just basically needed to add an irq to the APIC and read the scancode. But at the end what we got is just a number, and we want to eventually translated it into a character. 

In this section we will see see how to build the Keyboard driver, and what are its responsibilities. 

First of all the driver is not responsible of translating the scancode into printable characters (well sometime on early stages of development it does it too...)

What it cares is only to keep track of the various keyboard events and make them available to any service that needs them. jkjkjkjjjj

As already mentioned there are 3 different scancode sets, we will focus on just one (the set 1, since most of the keyboard even if using a different set will have the controller that automatically translates the scancode to that), by the way we will try to implement a generic way to translate, so when eventually a new set needs to be added the changes needed will be very little. 

Now let's see what are the problem we need to solve when developing a keyboard driver: 

* We need to store the history of key press and their status somewhere.
* There are some special keys also that needs to be handled, and some combinations that we should handle (shift or alt or ctrl  key pressed, are one example)
* Handle the press/release status if needed (we don't care much when we release a normal key, but probably we should take care when we release a key like shift or similars)
* Try to not lose sequence of key pressed/released
* Handle the caps, num, screen locks (with the leds)
* We need to translate the scancode into a human readable character when needed

From now on we will assume that the scancode translation is enabled, so no matter what set is being used it will be translate to set 1. 

## High Level Overview

In the previous section we have seen how the interrupt was generated and how to read data from the keyboard. But now we need to write a proper driver, trying to address the issues listed above (well not all of them since some are an higher level than they will be implemented "using" the driver, not by it.

We will try to build the driver in small step adding one piece at time, so it will be easier to understand it. 

### Store key press history

Of course the first thing we want to keep track of what is going on with the keyboard, we want to have a small buffer of what is being pressed released so far, and this is simple, we just need to declare an array to store the scancode read so far, the size of it is totally up to you, it doesn't need to be too big, in our example we will go for 255 items. We don't need to keep track of very old events, so when we reach the end of the buffer we will start over from the beginning (it is called a _circular buffer_)

What variable types the array should contain? Well the answer depends on several factors, for example: they set used, design decision, how we handle the special buttons. For example if we just want to store the scancode without any extra information we can just create an array of `uint8_t`:

```c
#define MAX_KEYB_BUFFER_SIZE    255

uint8_t keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;
```

If we want to store just the scancode we don't need much more so we can already implement our new irq handling function:

```c

void keyboard_driver_irq_handler() {

    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position] = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}

```

And we are done, this first function will keep track of the scancode generated by the keypress, and since we are using the set 1 it also will tell us if the button has been pressed (NAKE) or released (BREAK).

Now using uint8_t as buffer it can work in this exteremely simple scenario, but it make our driver hard to expand for future updates, for example what if we want to add some extra information with a single keypress event (and we will!)? So the first improvement we are going to make is creating a data structure that for now have just one field with the scancodae, but will make future expansion easier and more readable:

```c
typedef struct {
    uint8_t code;
} key_event;
```

So the updated irq function will be: 
```c
#define MAX_KEYB_BUFFER_SIZE    255

key_event keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;

void keyboard_driver_irq_handler() {    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position].code = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}
``` 

Even if this implementation has a lot of limitations, we implemented the first part of our driver: the circular buffer. Next we will see how to keep track of key press/released.

### Handling Press/Release status

In the previous paragraph we implemented the circular buffer and we now store every scancode that has been generated by the keyboard, now we will see how to store the button status (pressed or released).

> **_NOTE:_** Remember: the IRQ is fired for every byte put on the keyboard data buffer (and some keys generate a mutibyte scancode).



### TODO 

- Add syscall information 
