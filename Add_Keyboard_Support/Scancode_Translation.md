# Handling scancodes

Handling the keyboard interrupt was pretty simple, we just basically needed to add an irq to the APIC and read the scancode. But at the end of that is just a number we want it to be eventually translated into a character. 

This section will try to explain what is needed to translate them and what needs to be taken into account while developing a keyboard driver.

As already mentioned there are 3 different scancode sets, we will focus on just one (the set 1, since most of the keyboard even if using a different set will have the controller that automatically translates the scancode to that), by the way we will try to implement a generic way to translate, so when eventually a new set needs to be added the changes needed will be very little. 

Now let's see what are the problem we need to solve when developing a keyboard driver: 

* We need to store the history of key press and their status somewhere.
* There are some special keys also that needs to be handled, and some combinations that we should handle (shift or alt or ctrl  key pressed, are one example)
* Handle the press/release status if needed (we don't care much when we release a normal key, but probably we should take care when we release a key like shift or similars)
* Try to not lose sequence of key pressed/released
* Handle the caps, num, screen locks (with the leds)
* We need to translate the scancode into a human readable character when needed

From now on we will assume that the scancode translation is enabled, so no matter what set is being used it will be translate to set 1. 

## High Level Overview

In the previous section we have seen how the interrupt was generated and how to read data from the keyboard. But now we need to write a proper driver, trying to address the issues listed above (well not all of them since some are an higher level than they will be implemented "using" the driver, not by it.

We will try to build the driver in small step adding one piece at time, so it will be easier to understand it. 

### Store key press history

Of course the first thing we want to keep track of what is going on with the keyboard, we want to have a small buffer of what is being pressed released so far, and this is simple, we just need to declare an array to store the scancode read so far, the size of it is totally up to you, it doesn't need to be too big, in our example we will go for 255 items. We don't need to keep track of very old events, so when we reach the end of the buffer we will start over from the beginning (it is called a _circular buffer_)

What variable types the array should contain? Well the answer depends on several factors, for example: they set used, design decision, how we handle the special buttons. For example if we just want to store the scancode without any extra information we can just create an array of `uint8_t`:

```c
#define MAX_KEYB_BUFFER_SIZE    255

uint8_t keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;
```

If we want to store just the scancode we don't need much more so we can already implement our new irq handling function:

```c

void keyboard_driver_irq_handler() {

    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position] = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}

```

And we are done, this first function will keep track of the scancode generated by the keypress, and since we are using the set 1 it also will tell us if the button has been pressed (NAKE) or released (BREAK).

Now using uint8_t as buffer it can work in this exteremely simple scenario, but it make our driver hard to expand for future updates, for example what if we want to add some extra information with a single keypress event (and we will!)? So the first improvement we are going to make is creating a data structure that for now have just one field with the scancodae, but will make future expansion easier and more readable:

```c
typedef struct {
    uint8_t code;
} key_event;
```

So the updated irq function will be: 
```c
#define MAX_KEYB_BUFFER_SIZE    255

key_event keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;

void keyboard_driver_irq_handler() {    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position].code = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}
``` 

But it has a lot of limitations of course, for example it doesn't care about what the scancode is and it store it anyway, so if we have a multibyte scancode generated it stores all the byte, but some of them are not really useful (for example the extended byte E0 that we will se soon), or it doesn't keep track of key combinations, if we want to know if for example shift has been pressed to show capital letters we need to iterate the the whole buffer looking for the latest shift press event, but if we are typing a lot we can have lost it because of the circular buffer. 


### TODO 

- Add syscall information 
