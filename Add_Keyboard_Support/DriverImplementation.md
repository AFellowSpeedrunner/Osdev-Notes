# Handling scancodes

Handling the keyboard interrupt was pretty simple, we just basically needed to add an irq to the APIC and read the scancode. But at the end what we got is just a number, and we want to eventually translated it into a character. 

In this section we will see see how to build the Keyboard driver, and what are its responsibilities. 

First of all the driver is not responsible of translating the scancode into printable characters (well sometime on early stages of development it does it too...)

What it cares is only to keep track of the various keyboard events and make them available to any service that needs them.

As already mentioned there are 3 different scancode sets, we will focus on just one (the set 1, since most of the keyboard even if using a different set will have the controller that automatically translates the scancode to that), by the way we will try to implement a generic way to translate, so when eventually a new set needs to be added the changes needed will be very little. 

Now let's see what are the problem we need to solve when developing a keyboard driver: 

* We need to store the history of key press and their status somewhere.
* There are some special keys also that needs to be handled, and some combinations that we should handle (shift or alt or ctrl  key pressed, are one example)
* Handle the press/release status if needed (we don't care much when we release a normal key, but probably we should take care when we release a key like shift or similars)
* Try to not lose sequence of key pressed/released
* Handle the caps, num, screen locks (with the leds)
* We need to translate the scancode into a human readable character when needed

From now on we will assume that the scancode translation is enabled, so no matter what set is being used it will be translate to set 1. 

## High Level Overview

In the previous section we have seen how the interrupt was generated and how to read data from the keyboard. But now we need to write a proper driver, trying to address the issues listed above (well not all of them since some are an higher level than they will be implemented "using" the driver, not by it.

We will try to build the driver in small step adding one piece at time, so it will be easier to understand it. 

### Store key press history

Of course the first thing we want to keep track of what is going on with the keyboard, we want to have a small buffer of what is being pressed released so far, and this is simple, we just need to declare an array to store the scancode read so far, the size of it is totally up to you, it doesn't need to be too big, in our example we will go for 255 items. We don't need to keep track of very old events, so when we reach the end of the buffer we will start over from the beginning (it is called a _circular buffer_)

What variable types the array should contain? Well the answer depends on several factors, for example: they set used, design decision, how we handle the special buttons. For example if we just want to store the scancode without any extra information we can just create an array of `uint8_t`:

```c
#define MAX_KEYB_BUFFER_SIZE    255

uint8_t keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;
```

If we want to store just the scancode we don't need much more so we can already implement our new irq handling function:

```c

void keyboard_driver_irq_handler() {

    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position] = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}

```

And we are done, this first function will keep track of the scancode generated by the keypress, and since we are using the set 1 it also will tell us if the button has been pressed (MAKE) or released (BREAK).

Now using uint8_t as buffer it can work in this exteremely simple scenario, but it make our driver hard to expand for future updates, for example what if we want to add some extra information with a single keypress event (and we will!)? So the first improvement we are going to make is creating a data structure that for now have just one field with the scancodae, but will make future expansion easier and more readable:

```c
typedef struct {
    uint8_t code;
} key_event;
```

So the updated irq function will be: 
```c
#define MAX_KEYB_BUFFER_SIZE    255

key_event keyboard_buffer[MAX_KEYB_BUFFER_SIZE];
uint8_t buf_position = 0;

void keyboard_driver_irq_handler() {    
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    
    keyboard_buffer[buf_position].code = scancode;
    buf_position = (buf_position + 1) % MAX_KEYB_BUFFER_SIZE;

}
``` 

Even if this implementation has a lot of limitations, we implemented the first part of our driver: the circular buffer. Next we will see how to keep track of key press/released.

### Handle multi-byte scancodes

Dependending on the scancode set there are some keys that generated a scancode bigger than one byte. That means that we will have one IRQ generated for every byte placed on the data port. For example when using the scancode set 1 there are some keys (i.e. ctrl, shift, alt) that have a prefix number `0xE0`. Now the problem is that we can't read both bytes in one single irq, because even if we do, we still get two irqs generated. We need to keep track of the current reading status. To do that we will implement a very simple State Machine that have two states:

* _Normal State_, it is the standard state, also the one the driver starts in. If it read any byte that is not a prefix it will keep staying in this state, or it will re-enter into this state after a read while in the prefix state.
* _Prefix state_, in case it encountered a prefix (`0xE0`) the driver will enter into this state, in this way the next read will be completing the multi-byte scancode, and the driver will be able to identify the driver.

If you don't know what a state machine is look in the Useful Link section, for the wikipedia page. Btw the concept is pretty simple, is an algorithm that can be in one single state at each time, and update the states according to the input. In our case to implement it we need to add a global variable for the driver status, and for readability purpose two label that identifies the states.

```c
#define NORMAL_STATE 0
#define PREFIX_STATE 1

uint8_t current_state;
```

Now there are three scancodes thate are composed by  4 or 5, we are not going to cover them, but it can be a good exercise trying to find states for them too. The keys are Print Screen pressed/released and Pause (only pressed, it doesn't have a release state).

Now the first question is: do we need to store the prefix? Well for this one the answer is that it mostly depends on the design decision for the driver, but it is not necessary, especially if we are going to translate the keyboard scancodes into kernel scancodes (in this way we don't store a set specific code, and supporting multiple scancode will require less code, since the translation into a symol will be done from the kernel code and not the scancode). 

The state update is done by just updating the current_state variable. As already said that variable will start with the Normal State, so we will need an init function to e called before enabling the IRQ: 

```c
#define NORMAL_STATE 0
#define PREFIX_STATE 1

uint8_t current_state;

void init_keyboard() {
    // Do other initialization stuff like: clean the keyboard buffer, identify the scancode set, enable the IRQ etc.
    current_state = NORMAL_STATE;
}

void keyboard_driver_irq_handler() {
    int scancode = inb(0x60); // Read byte from the Keyboard data port
    if (scancode == 0xE0) {
        current_state = PREFIX_STATE
        // We have read a prefix, so let's update the state and finish here
        // this is a very simple scenario, there could be more needed depending on the design
        return;
    }
    if (current_state == PREFIX_STATE) {
        // Do what you need to store the key_code and eventually translate it to the kernel_code and return to the normal state
        current_state = NORMAL_STATE;
    }
}
```

The code snippet above just show how the states are updated, it doesn't care about the rest. Of course the state machine we have implemente is a very simple one, but if we are going for example to add support for the Print Screen and Pause key, it will probably have more states. The buffer update code can be reused from the previous paragraph. 

### Handling the "Special" keys

When talking about special keys we are referring to those keys that are considered like modifiers keys, when pressed they can alter the output from other keys (we are not talking about the scancode, but for the translated key), or they are simply used in combination with other keys, we are mostly referring to the _Ctrl_, _Alt_, _Shift_, and to some extent also the caps lock (even if this little bit easier to handle). 

When these keys are being kept presed the driver need to know this informantion, because it has to behave accordingly: 

* If the `shift` key is pressed the translation to ascii mechanism needs to know it because it has to return the Capital Symbol associated with that key (for Capital Symbol we mean or the Letter or the symbol above some keys) 
* If `ctrl` and `alt` are pressed the driver needs to know it because it can trigger either a key combination or some of the "Alt"ernative symbols on some special keyboard keys.
* If the caps lock key is pressed (not kept pressed) we need the translation function to return only the Capital version of the keys associated with alphabetical letters.
* The `fn` button is similar to `ctrl` and `alt` but it usually will just trigger an alternate "behaviour" for the keys (** TODO: check if changes the scancode generated by the key**)

So we basically need to keep track of the state of each of those buttons, and let the driver/translate function know if the keys are pressed. So it's time to update the key_event data structure. 
With what? Wel probably the first thing that could come to mind is to add a variable for each of the keys, something like: 

```c
typedef struct {
    uint8_t code;
    bool shift_pressed;
    bool alt_pressed;
    // ... etc
} key_event;

```

But this is not optimal, we have at least four buttons to track the status, and we can do it with a simple 1/0 status (1 for pressed 0 for released), so we can just store all of them in a single byte, and update the status with bitwise operations. 

```c
typedef struct {
    uint8_t code;
    uint8_t status_mask;
} key_event;
``` 

And now is just matter of associating each bit with the key we need to keep track, so for example bit 0 can be for the shift key, bit 1 for the ctrl key, etc. And the unused bits can be left as zero (and used for future needs)

A good habit should be to create labels with `#define` (or whatever your language of choice offers you) to identify those bits so for the following examples let's define the label for the shift key:

```c
# define CTRL_MASK 1
```

To update the bit we need to distinguish between the pressed case and the released case. Because to set a bit we need an or operation and to clear it we need an and. 

For example to set (key pressed) the CTRL status the update line will look like this:

```c
keyboard_position[i].status_mask = keyboard_position | (1 << CTRL_MASK);
```

and to clear (key released it):

```c
keyboard_position[i].status_mask = keyboard_position & ~(1 << CTRL_MASK);
```

So now we need to just identify what key is being pressed/released and update the status_mask accordingly. 

The case of caps lock can be handled in 2 ways, the first way is to add a boolean variable to the key_event struct to define the current keyboard status, or we can decide to use one of the unused bits in the status_mask. The only difference with the other cases is that we don't expect for the caps lock to be kept pressed. So the update will happen only once every key press (we don't care when it will be released). Ah and don't forget to update the led too.

### The translation

Now that all the parts of the driver are in place let's see how the translation will happen. 

There are two types of translation: 

* The first from scancode to kernel internal code (not mandatory but useful to support differents scancode sets)
* Second from kernel code to ascii character (even if not part of the driver itself is useful to know how it will happen)...

For the first translation what we basically need is to map the scancode number into an internal kernel code that will be the same for all the set our kernel will support (even if it will be only one).

Easiest way to handle it is with an array. The kernel codes is totally arbitrary there is no standard for it. Once decide for it just declare an array with all the scancodes represented: 

```c
    char scancode_mappings[] = { 
        0, 0x01, 0x02, 0x03, //... and so on
    }
```

where the numbers are the kernel code mappings. If we want to make the code more readable, a good idea could be to declare an enum that will contains the actual codes, and replace the numbers into the array with the enum label, like in the following example: 

```c
    typedef enum {
        ESCAPE = 0x01,
        F1 = 0x02,
        F2 = 0x03,
        //...
    } kernel_keycodes;
```

And now the array will looks like the following: 

```c
    kernel_keycodes scancode_mapping[] = {
        0, ESCAPE, F1, F2, //... and so on
    }
    
```

(0 is not associated to any scancode). 
### Handling Press/Release status

In the previous paragraph we implemented the circular buffer and we now store every scancode that has been generated by the keyboard, now we will see how to store the button status (pressed or released).

> **_NOTE:_** Remember: the IRQ is fired for every byte put on the keyboard data buffer (and some keys generate a mutibyte scancode).



### TODO 

- Add syscall information 
